# 상태관리와 반응형 프로그래밍

## 상태 관리

FE에서 상태관리에 대한 이슈는 뜨겁게 나타나고 있습니다. 기술이 고도화 되고 한 웹페이지에 나타나는 데이터의 양이 많아지면서 한 번의 데이터 변화가 일어날 때마다 웹페이지 전체가 새로고침 되는 현상은 매우 비효율적이게 되었습니다. 이를 해결하기 위해 나온 패러다임이 SPA(Single Page Application)입니다. 단 한번의 전체 렌더링만 이루어 지고 이후에는 변화하는 부분(컴포넌트)의 값만 변화시키는 방식입니다. 예를들어 인스타그램에서 좋아요를 누를때마다 전체 새로고침이 되지 않고 좋아요 빨강 처리와 좋아요 개수만 올라가게 됩니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/add4b618-3256-4142-b445-21fb4b2a99d4/Untitled.png)

그런데 여기서 상태관리 상태관리 하는데 “상태”가 무엇일까요? FE에서 “상태”란 변화하는 데이터를 의미합니다. 그리고 여러 컴포넌트들의 유기적인 집합(각각의 상태를 공유)으로 이루어진 웹 페이지에서 상태관리란, 변화하는 데이터를 유기적으로 처리하고 관리하는 기술이라고 할 수 있습니다.

> 추가적으로 FE는 비동기 처리가 많이 일어나는데, 비동기 처리에 따른 상태의 변화가 일어날때마다 새로고침이 일어나거나, 서로 연관되어 있는 데이터의 컴포넌트 값이 변화한다면 상당히 썩 유쾌한 일이 일어나지는 않을겁니다. 따라서 각각의 컴포넌트 상태관리를 해주는 것이 더욱 중요합니다.

---

## 반응형 프로그래밍

반응형 프로그래밍이란 선언형 프로그래밍의 종류 중 하나로 데이터 스트림과 그 변화에 대한 프로그래밍 패러다임입니다. 데이터 스트림에 더 집중하였기 때문에 데이터 흐름을 관찰하거나 필터링 하거나 다룰 수 있으며, 데이터 흐름을 서로 병합할 수 있습니다.

그렇다면 언제부터 반응형 프로그래밍 패러다임이 각광받게 되었을까요? 답은 위에서 언급한 상태관리에서 찾을 수 있습니다. SPA와 관련된 웹 프레임워크/라이브러리(React, Angular, Vue)가 출시됨에 따라 그에 상응하는 패러다임이 발전하게 된 것입니다.

### 반응형 프로그래밍 이전의 데이터 처리 방식

기존의 jQuery에서의 상태관리는 html에 jQuery를 덮어쓰는 형식으로 관리했습니다. 하나의 예시를 들어보겠습니다. element A,B,C가 존재한다고 할 때 element에는 각각 상태가 들어있습니다. C에서 event를 발생시킬 때 A와 B에있는 상태 값을 정제해서 API를 호출 C의 상태로 대입한다는 과정을 발생시킨다고 가정해보겠습니다. 위 과정을 수행하고 있는데 갑자기 A혹은 B의 상태 값이 바뀌게 된다면 그에 맞춰 나오는 C의 상태값 역시 변경되어야 합니다. 하지만, C의 상태값은 변경되지 않습니다. 즉, 우리가 원하는 값을 도출해주지 못합니다. jQuery는 DOM에 상태값을 저장하고 처리하는 DOM 제어방식이기 때문에 상태변화에 대한 추적이 어렵습니다.

```jsx
let a = 10,
  b = 20;
let c = a + b;
console.log(c); // c = 30;
a = 20;
console.log(c); // c = 30; c에 계산식의 결과값 30만 저장됨
```

기존의 방식에서는 c의 값은 40이 아닌 30이 나오게 됩니다. 도중에 a의 값이 변화하였음에도 c의 값은 이전의 a값을 유지합니다.

이러한 문제점이 있을 때, Angular가 등장하면서 웹 프레임워크에 큰 변화가 다음과 같이 일어나게 됩니다.

> 기존 방식인 DOM을 조작하기 쉽게 도와주는 형식에서 출력할 데이터에 초점을 맞추어서 데이터가 변경되면 자동으로 DOM을 렌더링되도록 하는 방식입니다.

데이터의 변화를 기준으로 변경되는 방식이 반응형 프로그래밍의 특징과 매우 유사합니다. 즉, 웹 프레임워크와 SPA가 등장함에 따라 반응형 프로그래밍이랑 패러다임이 뜨게 되었고, 그에 따라 상태관리가 FE에서 뜨거운 감자가 된 것입니다.

### 반응형에서의 데이터 전파 방식

반응형 프로그래밍에서 데이터 변경사항 전파 방식은 jQuery를 사용하던 때와는 다릅니다. jQuery에서는 DOM을 조작하여 화면 구성을 하기 때문에 render 하는 시점에서 필요한 데이터를 pull 해서 데이터를 업데이트 하는 방식을 사용했습니다.

하지만, 반응형 프로그래밍에서는 선언되어 있는 구조에 값이 변경될 때마다 템플릿으로 데이터를 전달하는 push 방식을 사용합니다. push와 pull 방식이 뭔지에 대해 좀 더 알아보겠습니다.

데이터 전파방식에 대해서 자세히 들어갔을 때 데이터를 생산하는 **생산자**가 있을 것이고 해당 데이터를 소비하는 **소비자**가 존재할 것입니다. 그리고 pull과 push의 관점은 해당 데이터 전파에 대한 **제어권** 여부를 두고 하는 말입니다.

여기서 데이터 생산자는 외부 환경에서 오는 데이터(ex : API) 이고, 데이터 소비자는 프로그램 자체입니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c515199-d837-4520-953f-0a03845a738c/Untitled.png)

위 그림을 보면 이해하기 쉽습니다. 기존의 pull 방식은 프로그램에서 외부 환경으로 필요한 데이터를 요청하는 형식입니다. 따라서 데이터를 불러오는 제어권은 프로그램에 존재합니다. 그것이 Interactive(pull) 방식*입니다.*
 반면에, push 방식은 프로그램과 외부 환경이 해당 데이터에 변화가 생긴다면 프로그램에 알려주기로 약속을 한 뒤 제어권을 외부 환경에 위임합니다. 그것이 Reactive(push) 방식입니다. 반응형으로 방식을 사용한다면 프로그램에서 데이터 변경에 대해 일일이 신경 쓰지 \*\* 않아도 되고 구독(?) 하고 있는 데이터 값에 변화가 존재한다면 외부 환경에서 알아서 처리해 줍니다. 반응형을 사용한다면 비동기가 난무하는 FE에서 일일이 데이터에 대한 제어를 하지 않아도 되는 편리함이 존재합니다. 하지만, 앞에서 언급했던 “약속”을 하는 것이 꼬여버린다면 오히려 독이 될 수도 있습니다.

### 반응형 프로그래밍 패턴

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f66c1829-f6bb-4bd5-a8f7-227b440a326e/Untitled.png)

반응형 프로그래밍 패턴에는 크게 2가지가 있습니다.

1. Observer 패턴

   Observer 패턴은 하나의 object가 존재하고, 그 object를 관찰하는 관찰자(observer)들이 존재합니다. 그리고 object는 관찰자들을 배열로 저장하고 있습니다. 해당 object의 state에 변화가 생긴다면, 구독하고 있는 관찰자들에게 상태 변화를 알려주고, 해당 값을 구독하고 있는 관찰자들은 변화된 값을 각각의 상태에 적용시킵니다.

2. Publish/Subscribe 패턴

   pub/sub 패턴은 observer에서 파생되어 나온 패턴인데, 구독과 fire하는 중간에 event Channel이 존재하여 각각의 상태와 구독 관계에 대해 관리해 줍니다. 이는 객체와 publisher간의 독립성을 유지시켜 주어서 서로에 대한 **결합도가 낮아집니다**. 이는 publisher를 확장하는데 있어서 더욱 유리하고 비동기 처리를 할 때 더욱 유리합니다.

위와 같은 구독 패턴이 사용되는 기능에는 `EventListener`가 있습니다. JS에서 이벤트를 동적으로 등록하고자 할 때 `addEventListener` 함수를 사용해서 component에 이벤트를 등록하고, 그 안에서 처리할 동작들을 지정할 수 있습니다. 이벤트 구독,해제 동작을 반응형 프로그래밍에서 사용한다고 볼 수 있습니다.

위 패턴들을 코드로 바꿔보면 다음과같이 볼 수 있습니다.

**Interactive Programming**

```jsx
//foo.js
import bar
import baz
import bass

function getResult(res){
	bar.addSmt(res.count)
	baz.loading()
	bass.createNode()
}
```

**Reactive Programming**

```jsx
// bar.js

import foo
foo.getResult(res => {addSmt(res.count)})

// baz.js
import foo
foo.getResult(res => {loading()})
```

하나의 파일에서 모든 처리를 한번에 실행하냐 or 각각의 독립된 파일에서 기능에만 맞게 사용하냐의 차이로 볼 수 있습니다.

좌측 코드의 경우 결합도가 높고, 데이터 관리가 어려운 반면에 우측 코드의 경우 결합도가 낮고, 데이터 관리가 더욱 수월합니다. (bar에서의 데이터는 bar파일에서만 처리 가능.)

위 코드를 보면 반응형 프로그래밍은 함수형 프로그래밍과 처리 방식이 유사하다는 것을 알 수 있습니다.

---

[https://www.youtube.com/watch?v=o4meZ7MRd5o](https://www.youtube.com/watch?v=o4meZ7MRd5o)

[https://velog.io/@hayeon/객제지향-vs-반응형-vs-함수형-프로그래밍#선언형-프로그래밍](https://velog.io/@hayeon/%EA%B0%9D%EC%A0%9C%EC%A7%80%ED%96%A5-vs-%EB%B0%98%EC%9D%91%ED%98%95-vs-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D#%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

[https://velog.io/@teo/reactive-programming#data-flow-프로그래밍](https://velog.io/@teo/reactive-programming#data-flow-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

[https://www.youtube.com/watch?v=alsCMx6vpG4](https://www.youtube.com/watch?v=alsCMx6vpG4)
