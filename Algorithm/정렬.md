# 정렬

## 선택 정렬

-   제자리 정렬 알고리즘 중 하나입니다.
    -   입력 배열 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법입니다.
-   해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘 입니다.
    -   첫 번째 순서에 첫 번째 위치에 가장 최솟값을 넣습니다
    -   두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣습니다
    -   ...

### 알고리즘 진행 순서

1. 주여진 배열 중 최솟값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다
3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다
4. 하나의 원소만 남을때까지 1~3 과정을 반복한다.

### 알고리즘 예제

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74f9386d-2dc8-48f8-bf1c-cc26e8952109/Untitled.png)

### 선택정렬 알고리즘의 특징

-   장점
    -   자료 이동 횟수가 미리 결정
-   단점
    -   안정성을 만족하지 않음 (값이 같은 레코드가 있는 경우 상대적인 위치가 변경될 수 있음)

**시간 복잡도: O(n^2)**

### JS로 구현한 코드

```jsx
function solution(arr) {
    for (let i = 0; i < arr.length; i++) {
        // arr 전체를 탐색
        let idx = i; // 현재 idx를 최소 idx로 가정
        for (let j = i + 1; j < arr.length; j++) {
            // 현재 idx 이후 탐색을 하며 최소 idx를 찾음
            if (arr[j] < arr[idx]) idx = j;
        }
        [arr[i], arr[idx]] = [arr[idx], arr[i]]; // 발견된 최솟값을 현재의 위치와 변환함
    }
    return arr;
}
```

## 버블 정렬

-   서로 인접한 두 원소를 검사하여 정렬하는 알고리즘입니다.
    -   인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환합니다.
-   선택 정렬과 기본 개념이 유사합니다

### 구체적 개념

-   버블 정렬은 인접한 자료끼리 서로 비교하며 교환하여 자료를 정렬합니다.
-   수행 회차가 증가할 수록 배열의 끝부분에서 부터 정렬에서 제외됩니다.

### 알고리즘 예제

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a1aa246-84cd-47c7-b9c1-76434d7a6e3e/Untitled.png)

### 알고리즘의 특징

-   장점
    -   구현이 간단하다
-   단점
    -   순서에 맞지 않은 요소를 인접한 요소와 교환한다
    -   요소의 교환에 있어서 지정된 위치 이전에 있는 모든 요소와 교환되어야 한다.(비효율적이다)
-   자료의 교환 작업이 자료의 이동 작업 보다 복잡하기 때문에 버블정렬은 거의 사용하지 않습니다.

**시간 복잡도: O(n^2)**

### JS로 구현한 코드

```jsx
function sol(arr) {
    for (let i = 0; i < arr.length; i++) {
        // arr 전체 탐색
        for (let j = 0; j < arr.length - i; j++) {
            // 마지막은 정렬이 되었기 때문에 i 만큼 빼줌
            if (arr[j] > arr[j + 1])
                // 이전 요소 값이 다음 요소값 보다 크다면 교환해줌.
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
    }
    return arr;
}
```

## 삽입 정렬

-   자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘 입니다.
-   매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣습니다.

### 구체적인 개념

-   두 번재 자료부터 시작해서 그 앞의 자료와 바교하며 삽입할 위치를 지정한 뒤, 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬합니다
-   자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킵니다.
-   처음 key 값은 두 번째 자료부터 시작합니다.

### 알고리즘 예시

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ecf68b63-07e6-4311-b33f-6a0790596cdb/Untitled.png)

### 알고리즘 특징

-   장점
    -   안정한 정렬 방법
    -   레코드 수가 적을 경우 다른 정렬 방법보다 유리함
    -   대부분 코드가 정렬되어 있는 경우에 매우 효율적인 방법
-   단점
    -   비교점 많은 레코드들의 이동을 포함
    -   레코드 수가 많고 각각의 크기가 클 경우 적합하지 않음

**시간 복잡도: O(n^2)**
