# 클래스

타입스크립트가 지원하는 클래스는 ECMAScript 6의 클래스와 유사하지만, 몇 가지 TypeScript만의 고유한 확장 기능이 있습니다.

## 1. 클래스 정의

ES6 클래스는 클래스 몸체에 메소드만 포함할 수 있습니다. 클래스 몸체에 클래스 프로퍼티를 선언할 수없고 생성자 내부에서 클래서 프로퍼티를 선언/초기화 합니다.

반면에 타입스크립트 클래스는 클래스 몸체에 클래스 프로퍼티를 사전에 선언해야 합니다.

```tsx
// person.ts
class Person {
    // 클래스 프로퍼티를 사전 선언하여야 한다
    name: string;

    constructor(name: string) {
        // 클래스 프로퍼티수에 값을 할당
        this.name = name;
    }

    walk() {
        console.log(`${this.name} is walking.`);
    }
}

const person = new Person("Lee");
person.walk(); // Lee is walking
```

## 2. 접근 제한자

타입스크립트는 클래스 기반 객체 지향 언어가 지원하는 접근 제한자(private,public,protedced)를 지원하며 의미 또한 동일합니다.

단, 접근 제한자를 명시하지 않았을 때 접근 제한자를 생략한 클래스 또는 프로퍼티와 메서드는 암묵적으로 public으로 선언됩니다. 따라서 public으로 지정하고 싶은 멤버 변수와 메서드는 접근 제한자를 생략합니다.

| 접근 가능성      | public | protected | private |
| ---------------- | ------ | --------- | ------- |
| 클래스 내부      | O      | O         | O       |
| 자식 클래스 내부 | O      | O         | X       |
| 클래스 인스턴스  | O      | X         | X       |

```tsx
class Foo {
    public x: string;
    protected y: string;
    private z: string;

    constructor(x: string, y: string, z: string) {
        // public, protected, private 접근 제한자 모두 클래스 내부에서 참조 가능하다.
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

const foo = new Foo("x", "y", "z");

// public 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조 가능하다.
console.log(foo.x);

// protected 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조할 수 없다.
console.log(foo.y);
// error TS2445: Property 'y' is protected and only accessible within class 'Foo' and its subclasses.

// private 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조할 수 없다.
console.log(foo.z);
// error TS2341: Property 'z' is private and only accessible within class 'Foo'.

class Bar extends Foo {
    constructor(x: string, y: string, z: string) {
        super(x, y, z);

        // public 접근 제한자는 자식 클래스 내부에서 참조 가능하다.
        console.log(this.x);

        // protected 접근 제한자는 자식 클래스 내부에서 참조 가능하다.
        console.log(this.y);

        // private 접근 제한자는 자식 클래스 내부에서 참조할 수 없다.
        console.log(this.z);
        // error TS2341: Property 'z' is private and only accessible within class 'Foo'.
    }
}
```

속성 관련 문제(맞는지는 모르겠음...)

```tsx
import "./style.css";
import { $, each } from "./utils";

//////////////////////////////////////////////////
// TypeScript 클래스 속성 접근 제어자
//////////////////////////////////////////////////

// 01. Navigation 컴포넌트 클래스 정의
// 02. 생성자로부터 전달받은 selector 인자를 `비공개` 속성으로 설정
// 03. selector 인자로부터 문서 객체를 찾아 el `공개` 속성에 설정
// 04. 난수(random number)를 id로 하는 `보호된` 속성을 설정

class Navigation {
    public el: Element;
    protected id: number;
    constructor(private selector: string) {
        this.el = document.querySelector(selector);
        this.id = Math.floor(Math.random() * 1000);
    }
}
```

## 3. 생성자 파라미터에 접근 제한자 선언

접근 제한자는 생성자 파라미터에도 선언할 수 있습니다. 이때 **접근 제한자가 사용된 생성자 파라미터는 암묵적으로 클래스 프로퍼티로 선언되고 생성자 내부에서 별도의 초기화 없어도 암묵적으로 초기화가 수행됩니다.**

만약에 접근 제한자가 private라면 클래스 내부에서만 참조 가능합니다.

```tsx
class Foo {
    /*
  접근 제한자가 선언된 생성자 파라미터 x는 클래스 프로퍼티로 선언되고 지동으로 초기화된다.
  public이 선언되었으므로 x는 클래스 외부에서도 참조가 가능하다.
  */
    constructor(public x: string) {}
}

const foo = new Foo("Hello");
console.log(foo); // Foo { x: 'Hello' }
console.log(foo.x); // Hello

class Bar {
    /*
  접근 제한자가 선언된 생성자 파라미터 x는 멤버 변수로 선언되고 자동으로 초기화된다.
  private이 선언되었으므로 x는 클래스 내부에서만 참조 가능하다.
  */
    constructor(private x: string) {}
}

const bar = new Bar("Hello");

console.log(bar); // Bar { x: 'Hello' }

// private이 선언된 bar.x는 클래스 내부에서만 참조 가능하다
console.log(bar.x); // Property 'x' is private and only accessible within class 'Bar'.
```

\*만약 생성자 파라미터에 접근제한자를 선언하지 않으면 생성자 파라미터는 생성자 내부에서만 유효한 지역변수가 되어 생성자 외부에서 참조가 불가능해집니다.

## 4. readonly 키워드

타입스크립트는 readonly 키워드를 사용할 수 있습니다. readonly가 선언된 클래스 프로퍼티는 선언시 또는 생성자 내부에서만 값을 할당할 수 있습니다. 그 외의 경우에는 읽기만 가능해집니다. 이를 통해 상수 선언을 사용합니다.

```tsx
class Foo {
    private readonly MAX_LEN: number = 5;
    private readonly MSG: string;

    constructor() {
        this.MSG = "hello";
    }

    log() {
        // readonly가 선언된 프로퍼티는 재할당이 금지된다.
        this.MAX_LEN = 10; // Cannot assign to 'MAX_LEN' because it is a constant or a read-only property.
        this.MSG = "Hi"; // Cannot assign to 'MSG' because it is a constant or a read-only property.

        console.log(`MAX_LEN: ${this.MAX_LEN}`); // MAX_LEN: 5
        console.log(`MSG: ${this.MSG}`); // MSG: hello
    }
}

new Foo().log();
```

## 5. stataic키워드

ES6 클래스에서 static 키워드는 클래스의 정적 메서드를 정의합니다. 정적 메서드는 클래스의 인스턴스가 아닌 클래스 이름으로 호출됩니다. 따라서 클래스 인스턴스를 생성하지 않고 호출이 가능합니다.

**타입스크립트에서는 static 키워드를 클래스 프로퍼티에도 사용할 수 있습니다**. 정적 메서드와 마찬가지로 정적 클래스 프로퍼티는 인스턴스가 아닌 클래스 이름으로 호출하며 클래스의 인스턴스를 생성하지 않아도 호출할 수 있습니다.

```tsx
class Foo {
    // 생성된 인스턴스의 갯수
    static instanceCounter = 0;
    constructor() {
        // 생성자가 호출될 때마다 카운터를 1씩 증가시킨다.
        Foo.instanceCounter++;
    }
}

var foo1 = new Foo();
var foo2 = new Foo();

console.log(Foo.instanceCounter); // 2
console.log(foo2.instanceCounter); // error TS2339: Property 'instanceCounter' does not exist on type 'Foo'.
```

## 6. 추상 클래스

**추상 클래스는 하나 이상의 추상 메서드**를 포함하여 일반 메서드도 포함할 수 있습니다. **추상 메서드**는 **내용이 없이 메서드 이름과 타입만이 선언된 메서드를 의미**합니다. 추상 클래스를 정의할 때는 abstract 키워드를 사용하고, 직접 인스턴스를 생성할 수 없고 상속만을 위해 사용됩니다. **추상클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구현**해야 합니다.

```tsx
abstract class Animal {
    // 추상 메소드
    abstract makeSound(): void;
    // 일반 메소드
    move(): void {
        console.log("roaming the earth...");
    }
}

// 직접 인스턴스를 생성할 수 없다.
// new Animal();
// error TS2511: Cannot create an instance of the abstract class 'Animal'.

class Dog extends Animal {
    // 추상 클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구현하여야 한다
    makeSound() {
        console.log("bowwow~~");
    }
}

const myDog = new Dog();
myDog.makeSound();
myDog.move();
```

\*인터페이스는 모든 메서드가 추상 메서드이지만 추상 클래스는 하나 이상의 추상 메서드와 일반 메서드를 포함할 수 있습니다.

참조

-   [https://poiemaweb.com/typescript-class](https://poiemaweb.com/typescript-class)
-   [https://yamoo9.gitbook.io/typescript/classes](https://yamoo9.gitbook.io/typescript/classes)
