# 실행 컨텍스트

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 개념입니다. 해당 개념을 잘 짚고 넘어가면, 자바스크립트의 동작이 어떻게 이루어 지는 지 알 수 있습니다.

### 1. 소스코드 타입

실행 컨텍스트를 생성하는 코드의 타입에는 4가지 종류가 있습니다.

1. 전역 코드: 전역에 존재하는 소스코드를 의미합니다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함하지 않습니다.
2. 함수 코드: 함수 내부에 존재하는 소스코드를 의미합니다. 중첩 함수 혹은 클래스 등의 내부코드는 포함하지 않습니다.
3. eval 코드: 사용하지 않습니다.
4. 모듈 코드: 모듈 내부에 존재하는 소스코드 입니다.

모든 소스코드는 해당 코드가 존재하는 스코프에서만 유효한 코드입니다. 해당 스코프를 넘어서 하위 혹은 상위 스코프를 포함하지 않습니다.

소스코드 타입이 나눠지는 이유는 각각의 타입에 따라 실행 컨텍스트의 과정과 관리가 달라지기 때문입니다.

**전역 코드**는 전역 변수 관리를 위한 최상위 스코프인 전역 스코프를 생성해야 합니다. 그리고 선언된 변수,함수들을 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 합니다.

**함수 코드**는 지역 스코프를 생성하고 지역 변수, 매개 변수 arguments 객체 관리를 해야합니다. 그리고 생성한 지역 스코프를 전역 스코프 체인의 일원으로 연결해야 합니다.

### 2. 소스코드의 평가와 실행

모든 소스코드는 실행에 앞서서 해당 코드를 평가합니다. 소스코드의 평가 과정에서는 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록합니다.

평가 과정이 끝나면 해당 소스코드를 순차적으로 실행(Runtime)합니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/42f79610-60aa-487f-944f-13b6823cbdc8/Untitled.png)

```jsx
var x;
x = 1;
```

소스코드 평가와 실행은 위 코드를 통해 알 수 있습니다. 소스 코드 평가는, `var x`를 실행하여 해당 식별자 `x`를 스코프에 등록하고 `undefined`로 초기화 합니다. 해당 과정이 끝나면 변수 할당문 `x = 1`을 실행하는데, 해당 식별자 `x` 가 실행 컨텍스트에 있는 스코프에 등록되어 있는지 확인 후 값을 할당합니다.

### 3. 실행 컨텍스트의 역할

```jsx
const x = 1;
const y = 2;

function foo(a) {
    const x = 10;
    const y = 20;

    console.log(a + x + y);
}

foo(100);

console.log(x + y);
```

위 소스코드를 실행한다고 했을 때, 아래와 같은 순서대로 동작이 일어납니다.

1. 전역코드 평가 → 스코프 생성, 식별자 구분, 코드 실행
2. 전역코드 실행 → 함수 코드 전 까지 실행하다, 함수코드가 등장하면 멈춤
3. 함수코드 평가 → 스코프 생성, 식별자 구분 코드 실행
4. 함수코드 실행 → 함수코드가 종료되고 나면 남은 전역코드를 실행

위 4가지의 동작을 업무로 나타내면 아래와 같습니다.

-   선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고, 상태변화를 지속적으로 관리
-   스코프는 중첩관계에 따라 스코프 체인 생성, 상위 스코프로 이동하면서 식별자 검색 가능
-   실행중인 코드의 실행 순서를 변경/복귀가 가능해야 함.

위 동작들을 관리하는 것이 실행 컨텍스트 입니다. 즉, **소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역입니다.**

**좀 더 자세히 보자면, 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, JS의 모든 코드는 실행 컨텍스트를통해 실행되고 관리됩니다.**

실행 컨텍스트는 식별자와 스코프를 관리하는 **렉시컬 환경**과 코드 실행 순서를 관리하는 **실행 컨텍스트 스택(콜 스택)** 2가지로 관리합니다.

### 4. 실행 컨텍스트 스택(콜 스택)

```jsx
const x = 1;

function foo() {
    const y = 2;
    function bar() {
        const z = 3;
        console.log(x + y + z);
    }
    bar();
}
foo();
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e9b83ff-4d5a-4df1-806c-183f922a82ed/Untitled.png)

위 코드가 실행되는 데에는 다음과 같은 그림의 순서대로 실행이 됩니다. 이를 **실행 컨텍스트 스택** 이라고 합니다. 자바 스크립트는 동작이 ‘싱글 스레드’를 제공한다고 많이 알려져 있습니다. (동기/비동기에 대해 공부하다 보면 제일 많이 들었던 말이죠?) 위 그림이 동기화 되는 하나의 그림이라고 이해하면 됩니다. 그림과 같이 하나의 스택에 처리해야 할 컨텍스트들이 차례대로 쌓이게 됩니다.

위 코드에서는 1개의 전역 컨텍스트와 2개의 함수 컨텍스트로 이루어져 있습니다. 일단 전역 컨텍스트를 평가를 하고 실행하는 도중에 `foo()` 함수 컨텍스트가 평가되고 실행 되며 그 도중에 `bar()`함수 컨텍스트가 평가되고 실행되는 방식입니다.

이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리합니다. 실행 컨텍스트 스택의 최상위에 있는 컨텍스트 스택은 항상 현재 실행중인 코드의 실행 컨텍스트 입니다. 이는 **실행중인 실행 컨텍스트**라고 부릅니다. (말이 좀 이상하다)

### 5. 렉시컬 환경

렉시컬 환경은 식별자와 식별자에 바인딩 된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트입니다. 식별자를 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리합니다.

렉시컬 환경은 두 개의 컴포넌트로 구성됩니다.

-   환경 레코드: 스코프에 포함된 식별자를 등록하고 등록됨 식별자에 바인딩 된 값을 관리하는 **저장소.** 소스 타입에 따라 관리하는 내용에 차이가 존재
-   외부 렉시컬 환경에 대한 참조: 상위 스코프를 의미. 상위 렉시컬 환경을 의미합니다. 이를 통해 단방향 링크드 리스트인 스코프 체인을 구현합니다.

### 6. 실행 컨텍스트의 생성과 식별자 검색 과정

```jsx
var x = 1;
const y = 2;

function foo(a) {
    var x = 3;
    const y = 4;

    function bar(b) {
        const z = 5;
        console.log(a + b + x + y + z);
    }
    bar(10);
}

foo(20);
```

### 1. **전역 객체 생성**

-   전역 객체는 전역 코드가 평가되기 이전에 생성됩니다.
-   빌트인 프로퍼티, 객체, 함수가 추가되며 동작 환경(클라이언트 사이드 or 서버 사이드)에 따라 Web API 혹은 호스트 객체를 포함합니다.
-   전역 객체도 Object.prototype을 상속 받는다.

### 2. **전역 코드 평가**

객체가 생성되고 소스코드를 평가하면서, 다음과 같은 순서로 평가가 이루어 집니다.

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
    1. 전역 환경 레코드 생성
        1. 객체 환경 레코드 생성
        2. 선언적 환경 레코드 생성
    2. this 바인딩
    3. 외부 렉시컬 환경에 대한 참조 결정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c262d828-64db-44a9-bf34-25876403ded3/Untitled.png)

전역 컨텍스트 평가를 마치고 나면 위 그림과 같은 구조로 식별자 생성이 완료됩니다.

**1.** **전역 컨텍스트 생성**

비어있는 전역 실행 컨텍스트를 생성해서 실행 컨텍스트 스택에 푸시합니다. 이때 전역 실행 컨텍스트는 실행중인 실행 컨텍스트가 됩니다. (최상단에 위치)

**2.** **전역 렉시컬 환경 생성**

렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성됩니다.

1. **전역 환경 레코드 생성**

    전역 환경 레코드는 전역 변수를 관리하는 전역 스코프, 전역 객체의 빌트인 전역 프로퍼티와 전역 함수, 표준 빌트인 객체를 제공합니다. 하지만 `const` 와 `let`으로 선언한 전역 변수들은 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재하게 됩니다.

    이처럼 변수 선언에 있어서 앞선 선언문의 차이에 따라 전역 환경 레코드는 **객체 환경 레코드와 선언적 환경 레코드** 2개로 나뉘게 됩니다. 전역 환경 레코드는위에 2개의 환경 레코드가 협력 하여 전역 스코프와 전역 객체를 관리합니다.

    - **객체 환경 레코드 생성**
        객체 환경 레코드는 `BindingObject`라 불리우는 객체와 연결됩니다. `BindingObject`는 앞서 **전역 객체 생성**에서 생성된 전역 객체입니다. 전역 코드 평가 과정에서 `var`키워드로 선언된 전역 변수나 함수 선언문으로 정의 된 전역 함수가 전역 객체의 프로퍼티와 메서드가 되고, 전역 객체를 가리키는 식별자(window) 없이 객체 프로퍼티를 참조할 수 있게 하는 메커니즘입니다.
        상단 코드에서 전역적으로 선언되어 있는 `x` 는 `var` 키워드로 선언된 변수이다. 즉, 전역 코드 평가 시점에서 전역 환경 레코드에 바인딩된 `BindingObject`를 통해 전역 객체에 변수 식별자를 키로 등록 한 뒤, 암묵적으로 undefined를 바인딩 한 것입니다. 따라서 x는 실행단계 이전에 변수 참조가 가능합니다.(비록 undefined 이지만) 이것이 **변수 호이스팅이 발생하는 원인이 됩니다**. 전역 코드 평가 과정에서 `var`로 선언된 전역변수의 값이 `undefined`로 바인딩 되기 때문이다.
        → 전역 환경 레코드 생성 과정에서 var 키워드로 선언된 변수는 객체 환경 레코드(전역 객체)로 분류되고, 그 과정에서 암묵적으로 undefined를 바인딩 하기 때문
        함수 선언문으로 정의된 함수가 평가되면, 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩 하고 키를 등록하고 생성된 함수 객체를 즉시 할당합니다. **즉, 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있습니다.**
    - **선언적 환경 레코드 생성**
        `let, const`로 선언한 전역변수는 선언적 환경 레코드에 등록되고 관리됩니다. `let, const` 부분에서 언급한 개념적인 블록이 전역 환경 레코드의 선언적 환경 레코드입니다. 따라서, `let, const`로 선언된 전역 변수는 전역 객체의 프로퍼티처럼 참조할 수 없고, 변수의 “선언 단계”와 “초기화 단계”가 분리되어 실행되기 때문에 <uninitialized> 할당(?) 되고 (값이 할당된 것은 아니다) 일시적 사각지대에 빠지게 됩니다.

2. **this 바인딩**

    전역 환경 레코드에서 전역 객체 this가 바인딩 됩니다. 전역 환경 레코드 내에 있는 객체 환경 레코드, 선언적 환경 레코드에는 this가 존재하지 않습니다. this는 전역 환경 레코드와 함수 환경 레코드에만 존재합니다.

3. **외부 렉시컬 환경에 대한 참조 결정**

    외부 렉시컬 환경이란 상위 스코프를 의미합니다. 하지만 전역 환경 레코드에서 상위 스코프는 존재하지 않으므로, 외부 렉시컬 환경에 null이 할당됩니다. 이는 전역 환경 레코드가 스코프 체인의 종점에 존재한다는 것을 알 수 있습니다.

### 3. **전역 코드 실행**

평가가 완료 되고 실행을 할 때에는 코드가 순차적으로 실행이 이루어 집니다. 변수 할당문, 혹은 함수 호출문을 실행하기 위해서는 먼저 선언된 변수나 함수의 명이 렉시컬 환경에 등록되어 있는지 확인해야 합니다. 선언되지 않았다면 사용할 수 없습니다. 다만, 식별자는 스코프가 다르면 이름이 중복되어도 됩니다. 이에 따라 어느 스코프의 식별자를 참조할 것인지 결정 할 필요가 있는데 이를 **식별자 결정**이라고 합니다.

식별자 결정을 하기 위해서 우선적으로 실행중인 실행 컨텍스트에서 식별자 검색을 시작합니다. 만약에 해당 컨텍스트에 선언된 식별자가 존재하지 않는다면, 스코프 체인을 따라 식별자 검색을 합니다. 만약, 스코프 체인의 종점에 이르렀을 때 선언된 변수의 식별자 등록이 되어있지 않는다면 참조 에러를 발생시킵니다. 이것이 스코프 체인의 동작 원리입니다.

### 4. **foo 함수 코드 평가**

전역 코드에서 foo 함수가 호출 된다면 **전역 코드의 실행이 일시 중단**되고 foo 함수 내부로 이동하고, 함수 코드를 평가합니다. 코드 평가는 다음과 같은 순서로 이루어집니다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
    1. 함수 환경 레코드 생성
    2. this 바인딩
    3. 외부 렉시컬 환경에 대한 참조 결정

**1. 함수 실행 컨텍스트 생성**

함수를 실행할 컨텍스트를 생성한 뒤 함수 렉시컬 환경 생성이 완료 된 다음에 실행 컨텍스트 스택 최상위에 푸시합니다.

**2. 함수 렉시컬 환경 생성**

함수 렉시컬 환경은 ‘렉시컬 환경’에서 언급한 것 같이 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성됩니다.

1. **함수 환경 레코드 생성**

    함수 환경 레코드는 매개변수, 인수(arguments), 함수 내부에 선언한 지역 변수들과 중첩 함수를 등록하고 관리합니다.

2. **this바인딩**

    함수 환경 레코드의 `[[ThisValue]]`내부 슬롯에 this가 바인딩 됩니다. 여기에 바인딩 되는 this는 호출 방식에 따라 다르게 바인딩 되는데, 앞선 코드는 일반 함수로 호출되므로 this는 전역 객체를 의미합니다.

3. **외부 렉시컬 환경에 대한 참조 결정**

    위 코드에서 foo 함수가 선언된 곳은 전역 코드입니다. 즉, foo 함수에서 참조하는 외부 렉시컬 함수는 전역 렉시컬 환경입니다. 그리고 이 상위 스코프를 함수 내부 슬롯 `[[Environment]]`에 저장하고, 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 `[[Environment]]`에 저장된 렉시컬 환경을 참조합니다.

### 5. **foo 함수 코드 실행**

평가가 완료된 함수 실행에 있어서 선언된 변수들이 함수 환경 레코드에 식별자로 존재한다면 초기화가 이루어지고 그게 아니라면 외부 렉시컬 환경에 대한 참조로 상위 스코프로 이동해서 현재 스코프에 존재하지 않는 식별자를 확인합니다.

### 6. **bar 함수 코드 평가**

foo 함수의 코드 평가와 동일합니다

### 7. **bar 함수 코드 실행**

foo 함수의 코드 실행과 동일합니다

### 8. **bar 함수 코드 실행 종료**

bar 함수, 즉 실행중인 실행 컨텍스트에서 pop 되고 난 다음에 존재하는 렉시컬 환경을 누군가가 참조하고 있다면 bar 렉시컬 함수는 소멸하지 않습니다.(클로저) 렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 독립적인 객체이다. **객체를 포함한 모든 값은 참조가 이루어지지 않을 때 가비지 컬렉터로 이동한다.**

### 9. **foo 함수 코드 실행 종료**

종료

### 10. **전역 코드 실행 종료**

종료

### 7. 실행 컨텍스트와 블록레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따릅니다. 하지만 let, const 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따릅니다.

```jsx
let x = 1;

if (true) {
    let x = 10;
    console.log(x); //10
}

console.log(x); // 1
```

해당 소스코드가 실행 순서는 아래와 같습니다.

-   전역 객체를 생성, 평가한 뒤 실행합니다.
-   실행하는 과정에서 if 문을 만났고, 해당 코드 블록이 실행되면서 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 합니다.
-   여기서 생성된 렉시컬 환경은 기존의 렉시컬 환경을 교체하게 됩니다. 여기서 새롭게 생성된 if문의 코드 블록의 외부 렉시컬 환경에 대한 참조는 if문이 실행되기 이전의 전역 렉시컬 환경을 의미합니다.
-   if문 코드 블록의 실행이 종료되면 if문의 코드 블록이 실행되기 이전의 렉시컬 환경으로 되돌아 갑니다. 이는 모든 블록 레벨 스코프를 통해 생성된는 블록문에 적용됩니다.

\*for 문의 변수 선언문에 let 키워드를 사용한 for 문은 코드 블록이 반복해서 실행될 때마다 코드 블록을 위한 렉시컬 환경을 생성합니다. 만약 for 문 내에 정의된 함수가 존재한다면 이 함수의 상위 스코프는 for 문의 코드 블록이 생성한 렉시컬 환경입니다.

이때 상의 스코프는 for 문의 코드 블록이 반복해서 실행될 때마다 식별자의 값을 유지해야 하는데, 이를 위해 for 문의 코드 블록이 반복해서 실행될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지합니다. 이는 [클로저](https://www.notion.so/24-52107fda33ca434c90613378c7102a8c)에서 자세히 다루어집니다.
